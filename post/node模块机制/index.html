<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-cn" lang="zh-cn">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.74.3" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Node模块机制 &middot; 阿泽的博客</title>
  <meta name="description" content="" />

  
  <link type="text/css" rel="stylesheet" href="https://liuzeaa.github.io/goblog/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://liuzeaa.github.io/goblog/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://liuzeaa.github.io/goblog/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://liuzeaa.github.io/goblog/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://liuzeaa.github.io/goblog/"><h1>阿泽的博客</h1></a>
      <p class="lead">
      An elegant open source and mobile first theme for <a href="http://hugo.spf13.com">hugo</a> made by <a href="http://twitter.com/mdo">@mdo</a>. Originally made for Jekyll.
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://liuzeaa.github.io/goblog/">Home</a> </li>
        
      </ul>
    </nav>

    <p>&copy; 2020. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>Node模块机制</h1>
  <time datetime=2018-01-08T16:11:02Z class="post-date">Mon, Jan 8, 2018</time>
  <p>JavaScript没有模块系统、标准库比较少、没有标准接口、缺乏包管理系统。
所以JavaScript社区提出了commonjs规范来解决这些问题。</p>
<!-- raw HTML omitted -->
<p>一个Node应用由模块组成，每个js文件就是一个独立模块。
npm基于commonjs实现包的管理使我们开发Node.js更方便。</p>
<h2 id="commonjs规范">commonjs规范</h2>
<h3 id="引用模块">引用模块</h3>
<p>在commonjs规范中，定义了 require() 方法，这个方法接受一个模块的标识。</p>
<pre><code>var math = require('math');
</code></pre><h3 id="定义模块">定义模块</h3>
<p>模块有自己的作用域。在模块里面定义的变量、函数、类，都是私有的，对其他文件不可见。</p>
<p>上下文中提供了一个 exports 对象可以导出当前模块的方法或者变量，并且它是唯一导出的出口。在模块中，还存在一个 module 对象，它代表当前模块，exports 是 module 的属性。</p>
<pre><code>// math.js
function add(a,b){
    return a + b;
}
exports.add = add;  # 导出一个add的方法
</code></pre><p>再新建一个文件就可以用 require()引用这个模块了</p>
<pre><code>// app.js
var math = require('math');
console.log(math.add(1,2)); # 3
</code></pre><h3 id="模块标识">模块标识</h3>
<p>模块标识就是传递给 require() 方法的参数，它必须是符合小驼峰命名的规范，或者以  .. 开头的相对路径，或者绝对路径。它可以没有文件后缀名.js。</p>
<h2 id="模块缓存">模块缓存</h2>
<p>加载模块后会被缓存,多次加载还是同一个对象。
查看模块缓存 require.cache
查看模块绝对路径  require.resolve(./math.js)
删除模块的缓存 require.cache[require.resolve(./math.js)]</p>
<h2 id="模块的循环加载">模块的循环加载</h2>
<pre><code>// a.js
console.log('a 开始');
exports.done = false;
const b = require('./b.js');
console.log('在 a 中，b.done = %j', b.done);
exports.done = true;
console.log('a 结束');

// b.js
console.log('b 开始');
exports.done = false;
const a = require('./a.js');
console.log('在 b 中，a.done = %j', a.done);
exports.done = true;
console.log('b 结束');

// main.js
console.log('main 开始');
const a = require('./a.js');
const b = require('./b.js');
console.log('在 main 中，a.done=%j，b.done=%j', a.done, b.done);
</code></pre><p>当 main.js 加载 a.js 时，a.js 又加载 b.js。 此时，b.js 会尝试去加载 a.js。 为了防止无限的循环，会返回一个 a.js 的 exports 对象的 未完成的副本 给 b.js 模块。 然后 b.js 完成加载，并将 exports 对象提供给 a.js 模块。</p>
<p>当 main.js 加载这两个模块时，它们都已经完成加载。 因此，该程序的输出会是：</p>
<pre><code>node main.js
main 开始
a 开始
b 开始
在 b 中，a.done = false
b 结束
在 a 中，b.done = true
a 结束
在 main 中，a.done=true，b.done=true
</code></pre><h2 id="module对象">module对象</h2>
<p>module.children  被该模块引用的模块对象。
module.id   模块的标识符。 通常是完全解析后的文件名。
module.parent 最先引用该模块的模块。
module.paths 模块的搜索路径。
&hellip; 更多去官网查询</p>
<h2 id="node的模块">Node的模块</h2>
<p>在Node中，模块分为两类：一类是Node提供的模块，称为核心模块。另外一类是用户编写的模块，称为文件模块。
核心模块定义在 Node.js 源代码的 lib/ 目录下。
require() 总是会优先加载核心模块。 例如，require(&lsquo;http&rsquo;) 始终返回内置的 HTTP 模块，即使有同名文件。</p>
<h2 id="moduleexports和exports区别">module.exports和exports区别</h2>
<p>exports是module.exports对象的引用</p>
<pre><code>function require(/* ... */) {
  const module = { exports: {} };
  ((module, exports) =&gt; {
    // 模块代码在这。在这个例子中，定义了一个函数。
    function someFunc() {}
    exports = someFunc;
    // 此时，exports 不再是一个 module.exports 的快捷方式，
    // 且这个模块依然导出一个空的默认对象。
    module.exports = someFunc;
    // 此时，该模块导出 someFunc，而不是默认对象。
  })(module, module.exports);
  return module.exports;
}
</code></pre><h1 id="参考">参考</h1>
<p><a href="http://nodejs.cn/api/modules.html#modules_cycles">http://nodejs.cn/api/modules.html#modules_cycles</a></p>

</div>


    </main>

    
      
    
  </body>
</html>
