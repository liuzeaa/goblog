<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-cn" lang="zh-cn">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.74.3" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>stream模块 &middot; 阿泽的博客</title>
  <meta name="description" content="" />

  
  <link type="text/css" rel="stylesheet" href="https://liuzeaa.github.io/goblog/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://liuzeaa.github.io/goblog/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://liuzeaa.github.io/goblog/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://liuzeaa.github.io/goblog/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://liuzeaa.github.io/goblog/"><h1>阿泽的博客</h1></a>
      <p class="lead">
      An elegant open source and mobile first theme for <a href="http://hugo.spf13.com">hugo</a> made by <a href="http://twitter.com/mdo">@mdo</a>. Originally made for Jekyll.
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://liuzeaa.github.io/goblog/">Home</a> </li>
        
      </ul>
    </nav>

    <p>&copy; 2020. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>stream模块</h1>
  <time datetime=2018-02-27T13:27:30Z class="post-date">Tue, Feb 27, 2018</time>
  <p>流（stream）在 Node.js 中是处理流数据的抽象接口。stream 模块提供了基础的 API 。使用这些 API 可以很容易地来构建实现流接口的对象。
Node.js 提供了多种流对象。 例如， HTTP 请求 和 process.stdout 就都是流的实例。
流可以是可读的、可写的，或是可读写的。所有的流都是 EventEmitter 的实例。</p>
<h2 id="为什么使用stream">为什么使用stream</h2>
<p>我们之前读文件用的是readFile()把整个文件读入到内存，如果文件小还可以，假如你读取的文件有几个G就会把内存撑爆，这个时候就需要stream(流)了，收到一块数据，就读取一块。这样占用内存就会小很多。</p>
<h2 id="流的类型">流的类型</h2>
<p>Node.js 中有四种基本的流类型：
Readable - 可读的流
Writable - 可写的流
Duplex - 可读写的流
Transform - 在读写过程中可以修改和变换数据的 Duplex 流</p>
<h2 id="可读流的常用事件">可读流的常用事件</h2>
<p>data 当有数据可读时触发
end 没有更多的数据可读时触发。
error  在接收和写入过程中发生错误时触发。</p>
<h2 id="可读流">可读流</h2>
<pre><code>let fs = require('fs');

let rs = fs.createReadStream('./hello.txt',{
    encoding: 'utf8'
});

rs.on('data', data =&gt; {
    console.log('读取中--------' + data +'--------') # 如果文件过大会分几次输出数据。
});

rs.on('end', () =&gt; {
    console.log('读取完毕'); # data读取完触发 end 事件。
})
</code></pre><p>第一个参数是路径。
第二个参数是可配置对象。</p>
<ul>
<li>flags: 读取模式默认为r（只读）</li>
<li>encoding: 设置编码默认null</li>
<li>mode: 设置文件模式默认0o666</li>
<li>start: 用整数表示文件开始读取字节数的索引位置</li>
<li>end: 用整数表示文件结束读取字节数的索引位置</li>
<li>highWaterMark: 最高水位线，停止从底层资源读取前，内部缓存区最多存放的字节数。默认64kb</li>
</ul>
<h3 id="暂停流对象触发-data-事件">暂停流对象触发 &lsquo;data&rsquo; 事件</h3>
<pre><code>rs.pause()
</code></pre><h3 id="重新流对象触发-data-事件">重新流对象触发 &lsquo;data&rsquo; 事件</h3>
<pre><code>rs.resume()
</code></pre><h2 id="可写流">可写流</h2>
<pre><code>let fs = require('fs');

let stream = fs.createWriteStream('./1.txt')

stream.write('lan') # 写入数据
stream.write('pang') # 写入数据
stream.end('zi') # 写入数据
stream.on('finish', function() {
    console.log(&quot;写入完成。&quot;);
});
</code></pre><p>第一个参数是路径。
第二个参数是可配置对象。</p>
<ul>
<li>flags: 读取模式默认为w</li>
<li>encoding: 设置编码默认utf8</li>
<li>mode: 设置文件模式默认0o666</li>
<li>start: 用整数表示文件开始写入字节数的索引位置</li>
<li>highWaterMark: 最高水位线，内部缓存区最多存放的字节数。默认16kb</li>
</ul>
<h3 id="streamwritechunk-encoding-callback">stream.write(chunk[, encoding][, callback])</h3>
<p>第一个参数写入的数据。
第二个参数设置编码。
第三个参数回调函数。
返回一个boolean值。
写入数据的时候内部缓冲区的大小小于创建流时设定的 highWaterMark 阈值，函数将返回 true 。如果返回值为 false ，应该停止向流中写入数据，直到 &lsquo;drain&rsquo; 事件被触发。</p>
<pre><code>let fs = require('fs');

let stream = fs.createWriteStream('./1.txt',{
    highWaterMark: 10
});

let i = 0;
let max = 100;
let write = () =&gt; {
    let flag = true;
    while (i &lt; max &amp;&amp; flag){
        console.log('写入' + i);
        i++;
        flag = stream.write(String(i));
    }
}
write();
stream.on('drain',() =&gt; {
    console.log('继续写入'+ i);
    write();
});
</code></pre><h3 id="drain事件">drain事件</h3>
<p>如果调用 stream.write(chunk) 方法返回 false，&lsquo;drain&rsquo; 事件会在适合恢复写入数据到流的时候触发。</p>
<h3 id="streamendchunk-encoding-callback">stream.end(chunk[, encoding][, callback])</h3>
<p>第一个参数写入的数据。
第二个参数设置编码。
第三个参数回调函数。
调用 writable.end() 方法表明接下来没有数据要被写入 Writable。通过传入可选的 chunk 和 encoding 参数，可以在关闭流之前再写入一段数据。如果传入了可选的 callback 函数，它将作为 &lsquo;finish&rsquo; 事件的回调函数。
在调用了 stream.end() 方法之后，再调用 stream.write() 方法将会导致错误。</p>
<h2 id="pipe">pipe()</h2>
<pre><code>let fs = require('fs');

let rs = fs.createReadStream('./1.txt');
let ws = fs.createWriteStream('./2.txt');
rs.pipe(ws)
</code></pre><p>readable.pipe(destination[, options])
readable 可读流对象
destination 可写流对象
readable.pipe() 绑定一个 Writable 到 readable 上， 将可写流自动切换到 flowing 模式并将所有数据传给绑定的 Writable。数据流将被自动管理。这样，即使是可读流较快，目标可写流也不会超负荷（overwhelmed）。
pipe 方法是使用流最简单的方式。通常的建议是要么使用 pipe 方法、要么使用事件来读取流，要避免混合使用两者。一般情况下使用 pipe 方法时你就不必再使用事件了。但如果你想以一种更加自定义的方式读取流，就要用到事件了。</p>
<h1 id="参考">参考</h1>
<p><a href="http://nodejs.cn/api/stream.html">http://nodejs.cn/api/stream.html</a></p>
</div>


    </main>

    
      
    
  </body>
</html>
